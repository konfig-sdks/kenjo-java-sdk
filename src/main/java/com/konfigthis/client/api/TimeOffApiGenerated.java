/*
 * Kenjo API
 * Before starting to use the Kenjo API, you have to request the API activation for a sandbox or production environment to the Kenjo Customer Success team. After that, an admin user has to go to *Settings > Integrations > API keys*, to generate the **API Key**. Follow the steps described in the **Autentication section** of this document. <br>The API key is needed to request the bearer token. Each endpoint callout requires a valid bearer token in the Authorization header. Once the token is retrieved, it will be useful during the time limit indicated by the 'expiration date'.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.TimeOffGetRequestsByDateResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class TimeOffApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public TimeOffApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public TimeOffApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call getRequestsByDateCall(String authorization, String from, String to, String userId, String timeOffTypeId, String status, Double offset, Double limit, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/time-off/requests";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (from != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("from", from));
        }

        if (to != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("to", to));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("_userId", userId));
        }

        if (timeOffTypeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("_timeOffTypeId", timeOffTypeId));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (authorization != null) {
            localVarHeaderParams.put("Authorization", localVarApiClient.parameterToString(authorization));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRequestsByDateValidateBeforeCall(String authorization, String from, String to, String userId, String timeOffTypeId, String status, Double offset, Double limit, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getRequestsByDate(Async)");
        }

        // verify the required parameter 'from' is set
        if (from == null) {
            throw new ApiException("Missing the required parameter 'from' when calling getRequestsByDate(Async)");
        }

        // verify the required parameter 'to' is set
        if (to == null) {
            throw new ApiException("Missing the required parameter 'to' when calling getRequestsByDate(Async)");
        }

        return getRequestsByDateCall(authorization, from, to, userId, timeOffTypeId, status, offset, limit, _callback);

    }


    private ApiResponse<TimeOffGetRequestsByDateResponse> getRequestsByDateWithHttpInfo(String authorization, String from, String to, String userId, String timeOffTypeId, String status, Double offset, Double limit) throws ApiException {
        okhttp3.Call localVarCall = getRequestsByDateValidateBeforeCall(authorization, from, to, userId, timeOffTypeId, status, offset, limit, null);
        Type localVarReturnType = new TypeToken<TimeOffGetRequestsByDateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getRequestsByDateAsync(String authorization, String from, String to, String userId, String timeOffTypeId, String status, Double offset, Double limit, final ApiCallback<TimeOffGetRequestsByDateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRequestsByDateValidateBeforeCall(authorization, from, to, userId, timeOffTypeId, status, offset, limit, _callback);
        Type localVarReturnType = new TypeToken<TimeOffGetRequestsByDateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetRequestsByDateRequestBuilder {
        private final String authorization;
        private final String from;
        private final String to;
        private String userId;
        private String timeOffTypeId;
        private String status;
        private Double offset;
        private Double limit;

        private GetRequestsByDateRequestBuilder(String authorization, String from, String to) {
            this.authorization = authorization;
            this.from = from;
            this.to = to;
        }

        /**
         * Set userId
         * @param userId This field allows to return only the time off requests for a given *_userId*. (optional)
         * @return GetRequestsByDateRequestBuilder
         */
        public GetRequestsByDateRequestBuilder userId(String userId) {
            this.userId = userId;
            return this;
        }
        
        /**
         * Set timeOffTypeId
         * @param timeOffTypeId This field allows to filter by time-off type Id. (optional)
         * @return GetRequestsByDateRequestBuilder
         */
        public GetRequestsByDateRequestBuilder timeOffTypeId(String timeOffTypeId) {
            this.timeOffTypeId = timeOffTypeId;
            return this;
        }
        
        /**
         * Set status
         * @param status This field allows to filter by the time-off request status. (optional)
         * @return GetRequestsByDateRequestBuilder
         */
        public GetRequestsByDateRequestBuilder status(String status) {
            this.status = status;
            return this;
        }
        
        /**
         * Set offset
         * @param offset Optional filter for pagination proposals. Determines the number of pages to skip when pagination is being used. If this value is not provided, by default the offset will be 1. (optional)
         * @return GetRequestsByDateRequestBuilder
         */
        public GetRequestsByDateRequestBuilder offset(Double offset) {
            this.offset = offset;
            return this;
        }
        
        /**
         * Set limit
         * @param limit Optional filter for pagination proposals. The maximum number of rows to retrieve which determines the size of the page. If this value is not provided then the limit will be 50 users. The maximum value of the limit is 100 users per page. Only are valid the following limit values: 25, 50 and 100. (optional)
         * @return GetRequestsByDateRequestBuilder
         */
        public GetRequestsByDateRequestBuilder limit(Double limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Build call for getRequestsByDate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> UNAUTHORIZED. The Authorization header is incorrect, not provided or the token expired. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getRequestsByDateCall(authorization, from, to, userId, timeOffTypeId, status, offset, limit, _callback);
        }


        /**
         * Execute getRequestsByDate request
         * @return TimeOffGetRequestsByDateResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> UNAUTHORIZED. The Authorization header is incorrect, not provided or the token expired. </td><td>  -  </td></tr>
         </table>
         */
        public TimeOffGetRequestsByDateResponse execute() throws ApiException {
            ApiResponse<TimeOffGetRequestsByDateResponse> localVarResp = getRequestsByDateWithHttpInfo(authorization, from, to, userId, timeOffTypeId, status, offset, limit);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getRequestsByDate request with HTTP info returned
         * @return ApiResponse&lt;TimeOffGetRequestsByDateResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> UNAUTHORIZED. The Authorization header is incorrect, not provided or the token expired. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<TimeOffGetRequestsByDateResponse> executeWithHttpInfo() throws ApiException {
            return getRequestsByDateWithHttpInfo(authorization, from, to, userId, timeOffTypeId, status, offset, limit);
        }

        /**
         * Execute getRequestsByDate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> UNAUTHORIZED. The Authorization header is incorrect, not provided or the token expired. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<TimeOffGetRequestsByDateResponse> _callback) throws ApiException {
            return getRequestsByDateAsync(authorization, from, to, userId, timeOffTypeId, status, offset, limit, _callback);
        }
    }

    /**
     * 
     * This endpoint returns a paginated list of time off requests for a given date range.The maximum number of time off requests to retrieve once is 92 days, so the URL params *from* and *to* are mandatory. The URL params help to return more accurate results.
     * @param authorization A valid bearer token. (required)
     * @param from A date in format YYYY-MM-DD to indicate the starting point. It needs to be equals or less than the *to* param. (required)
     * @param to A date in format YYYY-MM-DD to indicate the ending point. It needs to be equals or greater than the *from* param. (required)
     * @return GetRequestsByDateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> UNAUTHORIZED. The Authorization header is incorrect, not provided or the token expired. </td><td>  -  </td></tr>
     </table>
     */
    public GetRequestsByDateRequestBuilder getRequestsByDate(String authorization, String from, String to) throws IllegalArgumentException {
        if (authorization == null) throw new IllegalArgumentException("\"authorization\" is required but got null");
            

        if (from == null) throw new IllegalArgumentException("\"from\" is required but got null");
            

        if (to == null) throw new IllegalArgumentException("\"to\" is required but got null");
            

        return new GetRequestsByDateRequestBuilder(authorization, from, to);
    }
}
