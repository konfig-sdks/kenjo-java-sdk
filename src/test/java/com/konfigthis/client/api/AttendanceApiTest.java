/*
 * Kenjo API
 * Before starting to use the Kenjo API, you have to request the API activation for a sandbox or production environment to the Kenjo Customer Success team. After that, an admin user has to go to *Settings > Integrations > API keys*, to generate the **API Key**. Follow the steps described in the **Autentication section** of this document. <br>The API key is needed to request the bearer token. Each endpoint callout requires a valid bearer token in the Authorization header. Once the token is retrieved, it will be useful during the time limit indicated by the 'expiration date'.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.model.AttendanceCreateEntryRequest;
import com.konfigthis.client.model.AttendanceCreateEntryRequestBreaksInner;
import com.konfigthis.client.model.AttendanceCreateEntryResponse;
import com.konfigthis.client.model.AttendanceCreateTrackTimeRequest;
import com.konfigthis.client.model.AttendanceCreateTrackTimeResponse;
import com.konfigthis.client.model.AttendanceGetByIdResponse;
import com.konfigthis.client.model.AttendanceGetCategoriesResponse;
import com.konfigthis.client.model.AttendanceGetExpectedTimeByUserResponse;
import com.konfigthis.client.model.AttendanceGetListResponseInner;
import com.konfigthis.client.model.AttendanceUpdateEntryRequest;
import com.konfigthis.client.model.AttendanceUpdateEntryRequestBreaksInner;
import com.konfigthis.client.model.AttendanceUpdateEntryResponse;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeAll;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for AttendanceApi
 */
@Disabled
public class AttendanceApiTest {

    private static AttendanceApi api;

    
    @BeforeAll
    public static void beforeClass() {
        ApiClient apiClient = Configuration.getDefaultApiClient();
        api = new AttendanceApi(apiClient);
    }

    /**
     * This endpoint creates an attendance entry for a one employee, so an user *identifier* is required to build this relationship. The following *identifiers* are the valid ones: **userId**, **email** or **externalId**. Also one **startTime** and one **date** are required.&lt;br&gt;The new entry will have an unique identifier **_id**. This value is returned in the body response.&lt;br&gt;&lt;br&gt; A day accepts many attendance entries per employee but they cannot be overlapped. It means that if, for example, *there is an entry the 2021-06-10 between 09:00 and 10:00 for the user E-111, then the creation of an new entry for E-111 in the 2021-06-10 whose startDate or endDate is between 09:00 and 10:00 will become a BAD REQUEST*.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createEntryTest() throws ApiException {
        String date = null;
        String startTime = null;
        String authorization = null;
        String userId = null;
        String email = null;
        String externalId = null;
        String endTime = null;
        List<AttendanceCreateEntryRequestBreaksInner> breaks = null;
        String comment = null;
        AttendanceCreateEntryResponse response = api.createEntry(date, startTime, authorization)
                .userId(userId)
                .email(email)
                .externalId(externalId)
                .endTime(endTime)
                .breaks(breaks)
                .comment(comment)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint tracks time only providing the following information: **employee identifier** and a **date time**. The following identifiers are the valid ones: **userId**, **email** or **externalId**, only one of them is required. This action abstracts and simplifies the entries tracking, ensuring internally the order and transforming each track action to a Kenjo user attendance format.&lt;br&gt;&lt;br&gt;Example: Three calls for the employee E-111 to the *_/track-time* endpoint contains the following data:&lt;br&gt;T1: 2021-01-01T08:00:00&lt;br&gt;T2: 2021-01-01T09:00:00&lt;br&gt;T3: 2021-01-01T10:00:00&lt;br&gt;The three calls order is T1, T2, T3.&lt;br&gt;&lt;br&gt;Then in Kenjo there will be 2 attendance pairs:&lt;br&gt;1: 08:00 / 09:00&lt;br&gt;2: 10:00 / --:--&lt;br&gt;The second pair is open, with no **endTime** info, until a new one comes. &lt;br&gt;&lt;br&gt;If there is a new track: 2021-01-01T12:00:00, then the result will be:&lt;br&gt;1: 08:00 / 09:00&lt;br&gt;2: 10:00 / 12:00&lt;br&gt;If the track is 2021-01-01T07:00:00 instead, then the previous tracks are reordered to be consistent with concept of attendance pairs:&lt;br&gt;1: 07:00 / 08:00&lt;br&gt;2: 09:00 / 10:00
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createTrackTimeTest() throws ApiException {
        String dateTime = null;
        String authorization = null;
        String userId = null;
        String email = null;
        String externalId = null;
        AttendanceCreateTrackTimeResponse response = api.createTrackTime(dateTime, authorization)
                .userId(userId)
                .email(email)
                .externalId(externalId)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns one attendance entry specified by  **attendanceId**.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getByIdTest() throws ApiException {
        String attendanceId = null;
        String authorization = null;
        AttendanceGetByIdResponse response = api.getById(attendanceId, authorization)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns an array of objects. Every object contains an attendance category.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCategoriesTest() throws ApiException {
        String authorization = null;
        AttendanceGetCategoriesResponse response = api.getCategories(authorization)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns a paginated list of expected time by user for a given date range.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getExpectedTimeByUserTest() throws ApiException {
        String from = null;
        String to = null;
        String authorization = null;
        String companyId = null;
        String officeId = null;
        String departmentId = null;
        String userId = null;
        Double offset = null;
        Double limit = null;
        AttendanceGetExpectedTimeByUserResponse response = api.getExpectedTimeByUser(from, to, authorization)
                .companyId(companyId)
                .officeId(officeId)
                .departmentId(departmentId)
                .userId(userId)
                .offset(offset)
                .limit(limit)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns an array of objects with all the existing attendance entries within Kenjo for a maximum of 31 days, defined by the required params **from** and **to**. Every object contains an attendance entry.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getListTest() throws ApiException {
        String from = null;
        String to = null;
        String authorization = null;
        List<AttendanceGetListResponseInner> response = api.getList(from, to, authorization)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint delete the attendance entry specified by **attendanceId**.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void removeByIdTest() throws ApiException {
        String attendanceId = null;
        String authorization = null;
        api.removeById(attendanceId, authorization)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint updates the attendance entry specified by **attendanceId**. Only the fields submitted in the body will be updated.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateEntryTest() throws ApiException {
        String attendanceId = null;
        String authorization = null;
        String startTime = null;
        String endTime = null;
        List<AttendanceUpdateEntryRequestBreaksInner> breaks = null;
        String comment = null;
        AttendanceUpdateEntryResponse response = api.updateEntry(attendanceId, authorization)
                .startTime(startTime)
                .endTime(endTime)
                .breaks(breaks)
                .comment(comment)
                .execute();
        // TODO: test validations
    }

}
