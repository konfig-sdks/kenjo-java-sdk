/*
 * Kenjo API
 * Before starting to use the Kenjo API, you have to request the API activation for a sandbox or production environment to the Kenjo Customer Success team. After that, an admin user has to go to *Settings > Integrations > API keys*, to generate the **API Key**. Follow the steps described in the **Autentication section** of this document. <br>The API key is needed to request the bearer token. Each endpoint callout requires a valid bearer token in the Authorization header. Once the token is retrieved, it will be useful during the time limit indicated by the 'expiration date'.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.model.EmployeesCreateInactiveEmployeeRequest;
import com.konfigthis.client.model.EmployeesCreateInactiveEmployeeRequestAccount;
import com.konfigthis.client.model.EmployeesCreateInactiveEmployeeRequestAddress;
import com.konfigthis.client.model.EmployeesCreateInactiveEmployeeRequestFinancial;
import com.konfigthis.client.model.EmployeesCreateInactiveEmployeeRequestHome;
import com.konfigthis.client.model.EmployeesCreateInactiveEmployeeRequestPersonal;
import com.konfigthis.client.model.EmployeesCreateInactiveEmployeeRequestWork;
import com.konfigthis.client.model.EmployeesCreateInactiveEmployeeRequestWorkSchedule;
import com.konfigthis.client.model.EmployeesCreateInactiveEmployeeResponse;
import com.konfigthis.client.model.EmployeesGetAccountsResponse;
import com.konfigthis.client.model.EmployeesGetEmployeeInformationResponse;
import com.konfigthis.client.model.EmployeesGetListResponse;
import com.konfigthis.client.model.EmployeesGetWorkSchedulesResponse;
import com.konfigthis.client.model.EmployeesListAddressesResponse;
import com.konfigthis.client.model.EmployeesListFinancialsResponse;
import com.konfigthis.client.model.EmployeesListHomesResponse;
import com.konfigthis.client.model.EmployeesListPersonalsResponse;
import com.konfigthis.client.model.EmployeesListWorksResponse;
import com.konfigthis.client.model.EmployeesUpdateAddressRequest;
import com.konfigthis.client.model.EmployeesUpdateAddressResponse;
import com.konfigthis.client.model.EmployeesUpdateEmployeeAccountsRequest;
import com.konfigthis.client.model.EmployeesUpdateEmployeeAccountsResponse;
import com.konfigthis.client.model.EmployeesUpdateFinancialsRequest;
import com.konfigthis.client.model.EmployeesUpdateFinancialsResponse;
import com.konfigthis.client.model.EmployeesUpdateHomeRequest;
import com.konfigthis.client.model.EmployeesUpdateHomeResponse;
import com.konfigthis.client.model.EmployeesUpdatePersonalsRequest;
import com.konfigthis.client.model.EmployeesUpdatePersonalsResponse;
import com.konfigthis.client.model.EmployeesUpdateWorkScheduleRequest;
import com.konfigthis.client.model.EmployeesUpdateWorkScheduleResponse;
import com.konfigthis.client.model.EmployeesUpdateWorksRequest;
import com.konfigthis.client.model.EmployeesUpdateWorksResponse;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeAll;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for EmployeesApi
 */
@Disabled
public class EmployeesApiTest {

    private static EmployeesApi api;

    
    @BeforeAll
    public static void beforeClass() {
        ApiClient apiClient = Configuration.getDefaultApiClient();
        api = new EmployeesApi(apiClient);
    }

    /**
     * This endpoint activates a Kenjo employee given by the employeeId. It sends an email to the recipient of the employee email to start the onboarding process. Once the password is filled, the employee changes to &#39;active&#39; (&#39;isActive&#39; &#x3D; TRUE). While the employee is not active it is possible to send activation emails.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void activateEmployeeTest() throws ApiException {
        String employeeId = null;
        String authorization = null;
        String response = api.activateEmployee(employeeId, authorization)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint creates a deactivated employee in Kenjo, the &#39;isActive&#39; field set to false. To activate an employee use the put /activate method. This method will send an activation message to the employee email to complete the activation through the onboarding wizard. &lt;br&gt;&lt;br&gt;The field *email* is required and must be unique. Also *firstName*, *lastName* and *companyId* are required fields. If the work schedule is not provided then all the days of the week except Saturdays and Sundays are set to true. If the *language* is not specified, the assigned company language will be set by default. &lt;br&gt;&lt;br&gt;**Custom fields** information can be provided in this operation for the **personal**, **work**, **address**, **financial** and **home** sections. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with &#39;c_&#39; and the rest is composed by the trimmed name (spaces are removed). &lt;br&gt;&lt;br&gt; Example: &lt;br&gt; *The custom field &#39;Activity type&#39; belongs to the section &#39;work&#39;*:   &#x60;&#x60;&#x60; ... {   ...     \&quot;work\&quot;: {       \&quot;c_Activitytype\&quot;: \&quot;1\&quot;,       ...     },   ... } &#x60;&#x60;&#x60; *&#39;Activity type&#39; is a field type &#39;List&#39; (Strings list) with the possible values: \&quot;1\&quot;, \&quot;2\&quot; and \&quot;3\&quot;. It means that if a different value or type is provided then the request will return an error.* &lt;br&gt;&lt;br&gt;If the operation get success then an inactive employee is created and the response will include the provided information and the Kenjo id for the new employee. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createInactiveEmployeeTest() throws ApiException {
        String authorization = null;
        EmployeesCreateInactiveEmployeeRequestAccount account = null;
        EmployeesCreateInactiveEmployeeRequestPersonal personal = null;
        EmployeesCreateInactiveEmployeeRequestWork work = null;
        EmployeesCreateInactiveEmployeeRequestWorkSchedule workSchedule = null;
        EmployeesCreateInactiveEmployeeRequestAddress address = null;
        EmployeesCreateInactiveEmployeeRequestFinancial financial = null;
        EmployeesCreateInactiveEmployeeRequestHome home = null;
        EmployeesCreateInactiveEmployeeResponse response = api.createInactiveEmployee(authorization)
                .account(account)
                .personal(personal)
                .work(work)
                .workSchedule(workSchedule)
                .address(address)
                .financial(financial)
                .home(home)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint deactivates a Kenjo employee given by the employeeId. It sets the isActive field to FALSE and invalidate the access Kenjo for the employee. While the employee is not active it is possible to send activation emails.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deactivateEmployeeByIdTest() throws ApiException {
        String employeeId = null;
        String authorization = null;
        String response = api.deactivateEmployeeById(employeeId, authorization)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns a list with the **account** sections of the existing employees. The account section contains information such as *email*, *external Id*, *language* and *activation status*.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAccountsTest() throws ApiException {
        String authorization = null;
        String email = null;
        String language = null;
        String externalId = null;
        Boolean isActive = null;
        EmployeesGetAccountsResponse response = api.getAccounts(authorization)
                .email(email)
                .language(language)
                .externalId(externalId)
                .isActive(isActive)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns information about the **account**, **personal**, **work**, **work schedule**, **address**, **financial** and **home** sections for a given employee id. The *employeeId* param represents a Kenjo employee id.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEmployeeInformationTest() throws ApiException {
        String authorization = null;
        String employeeId = null;
        EmployeesGetEmployeeInformationResponse response = api.getEmployeeInformation(authorization, employeeId)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns the list of employee accounts existing in Kenjo. It is similar to the *_/employees/accounts* endpoint.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getListTest() throws ApiException {
        String authorization = null;
        EmployeesGetListResponse response = api.getList(authorization)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns a list with the **work schedule** sections of the existing employees.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getWorkSchedulesTest() throws ApiException {
        String authorization = null;
        Boolean trackAttendance = null;
        EmployeesGetWorkSchedulesResponse response = api.getWorkSchedules(authorization)
                .trackAttendance(trackAttendance)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns a list with the **address** sections of the existing employees.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listAddressesTest() throws ApiException {
        String authorization = null;
        String street = null;
        String postalCode = null;
        String city = null;
        String country = null;
        EmployeesListAddressesResponse response = api.listAddresses(authorization)
                .street(street)
                .postalCode(postalCode)
                .city(city)
                .country(country)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns a list with the **financial** sections of the existing employees.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listFinancialsTest() throws ApiException {
        String authorization = null;
        String accountHolderName = null;
        String bankName = null;
        String accountNumber = null;
        String iban = null;
        String swiftCode = null;
        String nationalId = null;
        String passport = null;
        String nationalInsuranceNumber = null;
        String taxCode = null;
        String taxIdentificationNumber = null;
        EmployeesListFinancialsResponse response = api.listFinancials(authorization)
                .accountHolderName(accountHolderName)
                .bankName(bankName)
                .accountNumber(accountNumber)
                .iban(iban)
                .swiftCode(swiftCode)
                .nationalId(nationalId)
                .passport(passport)
                .nationalInsuranceNumber(nationalInsuranceNumber)
                .taxCode(taxCode)
                .taxIdentificationNumber(taxIdentificationNumber)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns a list with the **home** sections of the existing employees.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listHomesTest() throws ApiException {
        String authorization = null;
        String maritalStatus = null;
        String spouseFirstName = null;
        String spouseLastName = null;
        String spouseBirthdate = null;
        String spouseGender = null;
        String personalEmail = null;
        String personalPhone = null;
        String personalMobile = null;
        EmployeesListHomesResponse response = api.listHomes(authorization)
                .maritalStatus(maritalStatus)
                .spouseFirstName(spouseFirstName)
                .spouseLastName(spouseLastName)
                .spouseBirthdate(spouseBirthdate)
                .spouseGender(spouseGender)
                .personalEmail(personalEmail)
                .personalPhone(personalPhone)
                .personalMobile(personalMobile)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns a list with the **personal** sections of the existing employees.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listPersonalsTest() throws ApiException {
        String authorization = null;
        String firstName = null;
        String lastName = null;
        String displayName = null;
        String gender = null;
        String birthdate = null;
        EmployeesListPersonalsResponse response = api.listPersonals(authorization)
                .firstName(firstName)
                .lastName(lastName)
                .displayName(displayName)
                .gender(gender)
                .birthdate(birthdate)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint returns a list with the **work** sections of the existing employees.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listWorksTest() throws ApiException {
        String authorization = null;
        String companyId = null;
        String officeId = null;
        String departmentId = null;
        String startDate = null;
        String jobTitle = null;
        String workPhone = null;
        String workMobile = null;
        Boolean isAssistant = null;
        String probationPeriodEnd = null;
        String reportsToId = null;
        EmployeesListWorksResponse response = api.listWorks(authorization)
                .companyId(companyId)
                .officeId(officeId)
                .departmentId(departmentId)
                .startDate(startDate)
                .jobTitle(jobTitle)
                .workPhone(workPhone)
                .workMobile(workMobile)
                .isAssistant(isAssistant)
                .probationPeriodEnd(probationPeriodEnd)
                .reportsToId(reportsToId)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint updates the employee **address** section for a given employee id. The operation only updates the fields provided in the body. &lt;br&gt;&lt;br&gt;**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with &#39;c_&#39; and the rest is composed by the trimmed name (spaces are removed). &lt;br&gt;&lt;br&gt; Example: &lt;br&gt; *The custom field &#39;province&#39; belongs to the &#39;address&#39; section*:   &#x60;&#x60;&#x60;   {     ...,     \&quot;country\&quot;: \&quot;ES\&quot;,     \&quot;c_province\&quot;: \&quot;MD\&quot;,     ...   } &#x60;&#x60;&#x60; *&#39;province&#39; is a field type &#39;String&#39;. It means that if a different type of data (number or boolean) is provided then the request will return an error.* 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateAddressTest() throws ApiException {
        String employeeId = null;
        String authorization = null;
        String street = null;
        String postalCode = null;
        String city = null;
        String country = null;
        EmployeesUpdateAddressResponse response = api.updateAddress(employeeId, authorization)
                .street(street)
                .postalCode(postalCode)
                .city(city)
                .country(country)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint updates the employee **account** section for a given employee id. The operation only updates the fields provided in the body.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateEmployeeAccountsTest() throws ApiException {
        String employeeId = null;
        String authorization = null;
        String email = null;
        String externalId = null;
        String language = null;
        EmployeesUpdateEmployeeAccountsResponse response = api.updateEmployeeAccounts(employeeId, authorization)
                .email(email)
                .externalId(externalId)
                .language(language)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint updates the employee **financial** section for a given employee id. The operation only updates the fields provided in the body. &lt;br&gt;&lt;br&gt;**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with &#39;c_&#39; and the rest is composed by the trimmed name (spaces are removed). &lt;br&gt;&lt;br&gt; Example: &lt;br&gt; *The custom field &#39;special tax&#39; belongs to the &#39;financial&#39; section*:   &#x60;&#x60;&#x60;   {     ...,     \&quot;iban\&quot;: \&quot;ES2345123456789077\&quot;,     \&quot;c_specialtax\&quot;: 1500,     ...   } &#x60;&#x60;&#x60; *&#39;special tax&#39; is a field type &#39;Number&#39;. It means that if a different type of data (string or boolean) is provided then the request will return an error.* 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateFinancialsTest() throws ApiException {
        String employeeId = null;
        String authorization = null;
        String accountHolderName = null;
        String bankName = null;
        String accountNumber = null;
        String iban = null;
        String swiftCode = null;
        String nationalId = null;
        String passport = null;
        String nationalInsuranceNumber = null;
        String taxCode = null;
        String taxIdentificationNumber = null;
        EmployeesUpdateFinancialsResponse response = api.updateFinancials(employeeId, authorization)
                .accountHolderName(accountHolderName)
                .bankName(bankName)
                .accountNumber(accountNumber)
                .iban(iban)
                .swiftCode(swiftCode)
                .nationalId(nationalId)
                .passport(passport)
                .nationalInsuranceNumber(nationalInsuranceNumber)
                .taxCode(taxCode)
                .taxIdentificationNumber(taxIdentificationNumber)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint updates the employee **home** section for a given employee id. The operation only updates the fields provided in the body. &lt;br&gt;&lt;br&gt;**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with &#39;c_&#39; and the rest is composed by the trimmed name (spaces are removed). &lt;br&gt;&lt;br&gt; Example: &lt;br&gt; *The custom field &#39;pet name&#39; belongs to the &#39;home&#39; section*:   &#x60;&#x60;&#x60;   {     ...,     \&quot;maritalStatus\&quot;: \&quot;Divorced\&quot;,     \&quot;c_petname\&quot;: \&quot;Boliche\&quot;,     ...   } &#x60;&#x60;&#x60; *&#39;pet name&#39; is a field type &#39;String&#39;. It means that if a different type of data (number or boolean) is provided then the request will return an error.* 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateHomeTest() throws ApiException {
        String employeeId = null;
        String authorization = null;
        String maritalStatus = null;
        String spouseFirstName = null;
        String spouseLastName = null;
        String spouseBirthdate = null;
        String spouseGender = null;
        String personalEmail = null;
        String personalPhone = null;
        String personalMobile = null;
        EmployeesUpdateHomeResponse response = api.updateHome(employeeId, authorization)
                .maritalStatus(maritalStatus)
                .spouseFirstName(spouseFirstName)
                .spouseLastName(spouseLastName)
                .spouseBirthdate(spouseBirthdate)
                .spouseGender(spouseGender)
                .personalEmail(personalEmail)
                .personalPhone(personalPhone)
                .personalMobile(personalMobile)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint updates the employee **personal** section for a given employee id. The operation only updates the fields provided in the body. &lt;br&gt;&lt;br&gt;**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with &#39;c_&#39; and the rest is composed by the trimmed name (spaces are removed). &lt;br&gt;&lt;br&gt; Example: &lt;br&gt; *The custom field &#39;category&#39; belongs to the &#39;personal&#39; section*:   &#x60;&#x60;&#x60;   {     ...,     \&quot;lastName\&quot;: \&quot;Nadie\&quot;,     \&quot;c_category\&quot;: \&quot;Good\&quot;,     ...   } &#x60;&#x60;&#x60; *&#39;category&#39; is a field type &#39;List&#39; (Strings list) with the possible values: \&quot;Good\&quot; and \&quot;Bad\&quot;. It means that if a different value or type is provided then the request will return an error.* 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updatePersonalsTest() throws ApiException {
        String employeeId = null;
        String authorization = null;
        String firstName = null;
        String lastName = null;
        String displayName = null;
        String gender = null;
        String birthdate = null;
        EmployeesUpdatePersonalsResponse response = api.updatePersonals(employeeId, authorization)
                .firstName(firstName)
                .lastName(lastName)
                .displayName(displayName)
                .gender(gender)
                .birthdate(birthdate)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint updates the employee **work schedule** section for a given employee id. The operation only updates the fields provided in the body.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateWorkScheduleTest() throws ApiException {
        String employeeId = null;
        String authorization = null;
        Boolean mondayWorkingDay = null;
        Boolean tuesdayWorkingDay = null;
        Boolean wednesdayWorkingDay = null;
        Boolean thursdayWorkingDay = null;
        Boolean fridayWorkingDay = null;
        Boolean saturdayWorkingDay = null;
        Boolean sundayWorkingDay = null;
        EmployeesUpdateWorkScheduleResponse response = api.updateWorkSchedule(employeeId, authorization)
                .mondayWorkingDay(mondayWorkingDay)
                .tuesdayWorkingDay(tuesdayWorkingDay)
                .wednesdayWorkingDay(wednesdayWorkingDay)
                .thursdayWorkingDay(thursdayWorkingDay)
                .fridayWorkingDay(fridayWorkingDay)
                .saturdayWorkingDay(saturdayWorkingDay)
                .sundayWorkingDay(sundayWorkingDay)
                .execute();
        // TODO: test validations
    }

    /**
     * This endpoint updates the employee **work** section for a given employee id. The operation only updates the fields provided in the body. &lt;br&gt;&lt;br&gt;**Custom fields** information can be provided in this operation. The *API name* of the custom field is required and the data format has to match with the type defined for the custom field in Kenjo. API names start with &#39;c_&#39; and the rest is composed by the trimmed name (spaces are removed). &lt;br&gt;&lt;br&gt; Example: &lt;br&gt; *The custom field &#39;activity type&#39; belongs to the &#39;personal&#39; section*:   &#x60;&#x60;&#x60;   {     ...,     \&quot;companyId\&quot;: \&quot;61d874aef37c05cfba4f1b38\&quot;,     \&quot;c_activityType\&quot;: \&quot;1\&quot;,     ...   } &#x60;&#x60;&#x60; *&#39;activity Type&#39; is a field type &#39;List&#39; (Strings list) with the possible values: \&quot;1\&quot; and \&quot;2\&quot;. It means that if a different value or type is provided then the request will return an error.* 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateWorksTest() throws ApiException {
        String employeeId = null;
        String authorization = null;
        String companyId = null;
        String officeId = null;
        String departmentId = null;
        String startDate = null;
        String jobTitle = null;
        String workPhone = null;
        String workMobile = null;
        Boolean isAssistant = null;
        String probationPeriodEnd = null;
        String reportsToId = null;
        EmployeesUpdateWorksResponse response = api.updateWorks(employeeId, authorization)
                .companyId(companyId)
                .officeId(officeId)
                .departmentId(departmentId)
                .startDate(startDate)
                .jobTitle(jobTitle)
                .workPhone(workPhone)
                .workMobile(workMobile)
                .isAssistant(isAssistant)
                .probationPeriodEnd(probationPeriodEnd)
                .reportsToId(reportsToId)
                .execute();
        // TODO: test validations
    }

}
